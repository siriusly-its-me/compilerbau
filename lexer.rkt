#lang racket
(require rebellion/type/enum)

(define DO_SYM 'DO_SYM)
(define ELSE_SYM 'ELSE_SYM)
(define IF_SYM 'IF_SYM)
(define WHILE_SYM 'WHILE_SYM)
(define LBRA 'LBRA)
(define RBRA 'RBRA)
(define LPAR 'LPAR)
(define RPAR 'RPAR)
(define PLUS 'PLUS)
(define MINUS 'MINUS)
(define LESS 'LESS)
(define SEMI 'SEMI)
(define EQUAL 'EQUAL)
(define INT 'INT)
(define ID 'ID)
(define EOI 'EOI)

(define id-name (make-list 100 #\space))

(define (next_ch)(read-char))

(define (next-sym)
    (case (peek-char)
      ((#\space #\newline)
       (next-ch)
       (again))
      ((EOF)
       (set! sym 'EOI))
      ((#\()
       (next-ch)
       (set! sym 'LPAR))
      ((#\) )
       (next-ch)
       (set! sym 'RPAR))
      ((#\{)
       (next-ch)
       (set! sym 'LBRA))
      ((#\})
       (next-ch)
       (set! sym 'RBRA))
      ((#\[)
       (next-ch)
       (set! sym 'LBRACK))
      ((#\])
       (next-ch)
       (set! sym 'RBRACK))
      ((#\<)
       (next-ch)
       (set! sym 'LESS))
      ((#\;)
       (next-ch)
       (set! sym 'SEMI))
      ((#\-)
       (next-ch)
       (set! sym 'MINUS))
      ((#\+)
       (next-ch)
       (set! sym 'PLUS))
      ((#\=)
       (next-ch)
       (set! sym 'EQUAL))
      (else
       (if (and (>= (peek-char) #\0) (<= (peek-char) #\9))
           (let loop ((int-val 0))
             (if (and (>= (peek-char) #\0) (<= (peek-char) #\9))
                 (begin
                   (set! int-val (+ (* int-val 10) (- (peek-char) #\0)))
                   (next-ch)
                   (loop int-val))
                 (set! sym 'INT)))
           (if (and (>= (peek-char) #\a) (<= (peek-char) #\z))
               (let* ((i 0)
                      (id-name (make-string 100))) ; Ajustez la taille de la chaîne selon vos besoins
                 (let loop ((ch (peek-char)))
                   (if (or (and (>= ch #\a) (<= ch #\z)) (= ch #\_))
                       (begin
                         (string-set! id-name i ch)
                         (next-ch)
                         (loop (peek-char))
                         (set! i (+ i 1)))
                       (begin
                         (string-set! id-name i #\null)
                         (set! sym 0)
                         (let loop ((sym 0))
                           (if (and (not (null? (vector-ref words sym)))
                                    (not (string=? (vector-ref words sym) id-name)))
                               (begin
                                 (set! sym (+ sym 1))
                                 (loop sym))
                               (if (null? (vector-ref words sym))
                                   (if (= (string-length id-name) 1)
                                       (set! sym 'ID)
                                       (syntax-error))
                                   (void))))))))
               (syntax-error))))))

(define (next-ch)
  ; Remplacez cette fonction avec la logique de lecture réelle
  ; (par exemple, depuis une chaîne ou une portée d'entrée)
  (display "Simuler la lecture du caractère suivant.\n")
  (read-char))

(define (syntax-error)
  (display "Erreur de syntaxe.\n"))

